{"version":3,"file":"meatwagon.browser.min.js","sources":["../src/meatwagon.js"],"sourcesContent":["const tagPattern = /^(?<tagName>[\\w-]+)?(?<ids>(?:[\\.#][\\w-]+)*)(?:\\((?<attrs>[^\\n]*?)\\))?(?:\\s(?<text>[\\s\\S]+)?|(?<dot>\\.))?$/;\nconst classesPattern = /(\\.[\\w-]+)/g;\nconst idsPattern = /(#[\\w-]+)/g;\nconst indentation = /^\\s*/;\nconst controlOpPattern = /^((if|while|for)\\s*\\([\\s\\S]+\\)|else)$/;\nconst countIndentation = str => indentation.exec(str)[0].length;\nconst atomic = ['br', 'img', 'hr', 'area', 'base', 'col', 'command', 'embed', 'input', 'link', 'meta', 'keygen', 'param', 'source', 'track', 'wbr'];\n\nconst parse = input => {\n    const lines = input.split(/\\r?\\n/g);\n    const tree = {\n        type: 'root',\n        children: []\n    };\n    const depthStack = [-1],\n          tagStack = [];\n    let currContainer = tree,\n        prevNode = tree;\n    let dotTag, dotDepth;\n    const goUp = () => {\n        tagStack.pop();\n        depthStack.pop();\n        currContainer = tagStack[tagStack.length - 1];\n    };\n    const goDown = (node, depth) => {\n        depthStack.push(depth);\n        tagStack.push(node);\n        currContainer = node;\n    };\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const trimmed = line.trim();\n        if (trimmed === '') {\n            continue;\n        }\n        const lastDepth = depthStack[depthStack.length - 1];\n        const newDepth = countIndentation(line);\n        if (dotTag) {\n            if (dotDepth < newDepth) {\n                dotTag.children.push({\n                    type: 'text',\n                    value: line.slice(dotDepth) + '\\n'\n                });\n                continue;\n            } else {\n                dotTag = false;\n            }\n        }\n        let newNode;\n        if (trimmed[0] === '|') {\n            newNode = {\n                type: 'text',\n                value: trimmed.slice(1).trimStart() || ' '\n            };\n        } else if (trimmed.startsWith('//')) {\n            if (trimmed[2] === '-') {\n                newNode = {\n                    type: 'comment',\n                    value: trimmed.slice(3)\n                };\n            }\n        } else if (trimmed[0] === '-') {\n            newNode = {\n                type: 'code',\n                value: trimmed.slice(1).trim(),\n                children: []\n            };\n        } else {\n            const parsed = tagPattern.exec(trimmed);\n            if (!parsed) {\n                throw new Error(`Line ${i + 1}: malformed tag.\\n${trimmed}`);\n            }\n            const {tagName, ids, attrs, text, dot} = parsed.groups;\n            newNode = {\n                type: 'tag',\n                tagName: tagName || 'div',\n                ids,\n                attrs,\n                hasText: Boolean(text),\n                children: [],\n                atomic: atomic.includes(tagName)\n            };\n            if (dot) {\n                dotTag = newNode;\n                dotDepth = newDepth;\n                newNode.children.push({\n                    type: 'text',\n                    value: '\\n'\n                });\n            } else if (text) {\n                if (newNode.atomic) {\n                    throw new Error(`Line ${i + 1}: tag ${tagName} cannot have a text node.\\n${trimmed}`)\n                }\n                newNode.children.push({\n                    type: 'text',\n                    value: text.trim()\n                });\n            }\n        }\n        if (newDepth < lastDepth) {\n            const depthInd = depthStack.indexOf(newDepth);\n            if (depthInd === -1) {\n                throw new Error(`Bad indentation at line ${i + 1}, expected depth: ${depthStack.join(', ')} spaces, got ${newDepth}.\\n${line}`);\n            }\n            while (depthStack[depthStack.length - 1] !== newDepth) {\n                goUp();\n            }\n            currContainer.children.push(newNode);\n        } else if (newDepth > lastDepth) {\n            if (!('children' in currContainer)) {\n                throw new Error(`Line ${i + 1}: entry of type ${currContainer.type} cannot have children.\\n${line}`);\n            }\n            if (currContainer.type === 'tag') {\n                if (atomic.includes(currContainer.tagName)) {\n                    throw new Error(`Line ${i + 1}: tag ${currContainer.tagName} cannot have children.\\n${line}`);\n                }\n                if (currContainer.hasText) {\n                    throw new Error(`Line ${i + 1}: tag ${currContainer.tagName} has a text node and cannot have children.\\n${line}`);\n                }\n            }\n            goDown(prevNode, newDepth);\n            currContainer.children.push(newNode);\n        } else {\n            currContainer.children.push(newNode);\n        }\n        prevNode = newNode;\n    }\n    return tree;\n};\n\nconst escapist = /'/g;\nconst escapeQuotes = str => str.replace(escapist, '\\\\`');\n\nconst getClassesIds = ids => {\n    const id = idsPattern.exec(ids)?.[0],\n          classes = ids.match(classesPattern);\n    let str = '';\n    if (id) {\n        str += ` id=\"${id.slice(1)}\" `;\n    }\n    if (classes?.length) {\n        str += ' class=\"';\n        for (const c of classes) {\n            str += c.slice(1) + ' ';\n        }\n        str = str.slice(0, -1) + '\" ';\n    }\n    return str.slice(0, -1);\n};\n\nlet isPrevNodeHtml;\nconst looseEnd = isHtml => {\n    let output = '';\n    if (isPrevNodeHtml && !isHtml) {\n        output = '`;';\n    } else if (!isPrevNodeHtml && isHtml) {\n        output = 'html+=`';\n    }\n    isPrevNodeHtml = isHtml;\n    return output;\n};\n\nconst walk = node => {\n    if (node instanceof Array) {\n        return node.map(walk).join('');\n    }\n    let out;\n    switch (node.type) {\n        case 'comment':\n            return `${looseEnd(true)}<!--${escapeQuotes(node.value)}-->`;\n        case 'code':\n            out = looseEnd(false) + node.value;\n            const b = controlOpPattern.test(node.value);\n            if (b) {\n                out += '{';\n            }\n            if (node.children?.length) {\n                out += walk(node.children);\n            }\n            if (b) {\n                out += `${looseEnd(false)}}`;\n            }\n            isPrevNodeHtml = false;\n            return out;\n        case 'text':\n            return `${looseEnd(true)}${escapeQuotes(node.value)}`;\n        case 'tag':\n            const a = node.atomic;\n            let attrsString = node.attrs? (' ' + node.attrs) : '';\n            if (node.ids) {\n                attrsString += getClassesIds(node.ids);\n            }\n            out = `${looseEnd(true)}<${node.tagName}${escapeQuotes(attrsString)}${a ? '/' : ''}>`;\n            if (node.children?.length) {\n                out += walk(node.children);\n            }\n            if (!a) {\n                out += `${looseEnd(true)}</${node.tagName}>`;\n            }\n            isPrevNodeHtml = true;\n            return out;\n    }\n};\nconst makeRenderer = code => {\n    try {\n        return new Function('state', code);\n    } catch (e) {\n        console.error(code);\n        throw new Error(`Malformed JS code: ${e.message}`);\n    }\n};\nconst compile = tree => {\n    let output = 'let html = \\'\\';';\n    isPrevNodeHtml = false;\n    output += walk(tree.children);\n    if (isPrevNodeHtml) {\n        output += '`;';\n    }\n    output += 'return html;'\n    return output;\n};\nexport default {\n    render(input, state = {}) {\n        const tree = parse(input);\n        const compiled = compile(tree);\n        return makeRenderer(compiled)(state);\n    },\n    renderer(input) {\n        return makeRenderer(compile(parse(input)));\n    }\n};"],"names":["tagPattern","classesPattern","idsPattern","indentation","controlOpPattern","atomic","parse","input","lines","split","tree","type","children","depthStack","tagStack","dotTag","dotDepth","currContainer","prevNode","i","length","line","trimmed","trim","lastDepth","newDepth","str","exec","push","value","slice","newNode","trimStart","startsWith","parsed","Error","tagName","ids","attrs","text","dot","groups","hasText","Boolean","includes","indexOf","join","pop","node","depth","escapist","escapeQuotes","replace","isPrevNodeHtml","looseEnd","isHtml","output","walk","Array","map","out","b","test","a","attrsString","id","classes","match","c","getClassesIds","makeRenderer","code","Function","e","console","error","message","compile","render","state","compiled","renderer"],"mappings":"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"}