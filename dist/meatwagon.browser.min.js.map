{"version":3,"file":"meatwagon.browser.min.js","sources":["../src/meatwagon.js"],"sourcesContent":["const tagPattern = /^(?<tagName>[\\w-]+)?(?<ids>(?:[\\.#][\\w-]+)*)(?:\\((?<attrs>[^\\n]*?)\\))?(?:\\s(?<text>[\\s\\S]+)?|(?<dot>\\.))?$/;\nconst classesPattern = /(\\.[\\w-]+)/g;\nconst idsPattern = /(#[\\w-]+)/g;\nconst indentation = /^\\s*/;\nconst controlOpPattern = /^((if|while|for)\\s*\\([\\s\\S]+\\)|else)$/;\nconst countIndentation = str => indentation.exec(str)[0].length;\nconst atomic = ['br', 'img', 'hr', 'area', 'base', 'col', 'command', 'embed', 'input', 'link', 'meta', 'keygen', 'param', 'source', 'track', 'wbr'];\n\nconst parse = input => {\n    const lines = input.split(/\\r?\\n/g);\n    const tree = {\n        type: 'root',\n        children: []\n    };\n    const depthStack = [-1],\n          tagStack = [];\n    let currContainer = tree,\n        prevNode = tree;\n    let dotTag, dotDepth, dotTextDepth = null;\n    const goUp = () => {\n        tagStack.pop();\n        depthStack.pop();\n        currContainer = tagStack[tagStack.length - 1];\n    };\n    const goDown = (node, depth) => {\n        depthStack.push(depth);\n        tagStack.push(node);\n        currContainer = node;\n    };\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const trimmed = line.trim();\n        if (trimmed === '') {\n            if (dotTag) {\n                dotTag.children.push({\n                    type: 'text',\n                    value: '\\n'\n                });\n            }\n            continue;\n        }\n        const lastDepth = depthStack[depthStack.length - 1];\n        const newDepth = countIndentation(line);\n        if (dotTag) {\n            if (dotDepth < newDepth) {\n                if (dotTextDepth === null) {\n                    dotTextDepth = newDepth;\n                }\n                dotTag.children.push({\n                    type: 'text',\n                    value: line.slice(dotTextDepth) + '\\n'\n                });\n                continue;\n            } else {\n                dotTag = false;\n                dotTextDepth = null;\n            }\n        }\n        let newNode;\n        if (trimmed[0] === '|') {\n            newNode = {\n                type: 'text',\n                value: trimmed.slice(1).trimStart() || ' '\n            };\n        } else if (trimmed.startsWith('//')) {\n            if (trimmed[2] === '-') {\n                newNode = {\n                    type: 'comment',\n                    value: trimmed.slice(3)\n                };\n            }\n        } else if (trimmed[0] === '-') {\n            newNode = {\n                type: 'code',\n                value: trimmed.slice(1).trim(),\n                children: []\n            };\n        } else {\n            const parsed = tagPattern.exec(trimmed);\n            if (!parsed) {\n                throw new Error(`Line ${i + 1}: malformed tag.\\n${trimmed}`);\n            }\n            const {tagName, ids, attrs, text, dot} = parsed.groups;\n            newNode = {\n                type: 'tag',\n                tagName: tagName || 'div',\n                ids,\n                attrs,\n                hasText: Boolean(text),\n                children: [],\n                atomic: atomic.includes(tagName)\n            };\n            if (dot) {\n                dotTag = newNode;\n                dotDepth = newDepth;\n                newNode.children.push({\n                    type: 'text',\n                    value: '\\n'\n                });\n            } else if (text) {\n                if (newNode.atomic) {\n                    throw new Error(`Line ${i + 1}: tag ${tagName} cannot have a text node.\\n${trimmed}`)\n                }\n                newNode.children.push({\n                    type: 'text',\n                    value: text.trim()\n                });\n            }\n        }\n        if (newDepth < lastDepth) {\n            const depthInd = depthStack.indexOf(newDepth);\n            if (depthInd === -1) {\n                throw new Error(`Bad indentation at line ${i + 1}, expected depth: ${depthStack.join(', ')} spaces, got ${newDepth}.\\n${line}`);\n            }\n            while (depthStack[depthStack.length - 1] !== newDepth) {\n                goUp();\n            }\n            currContainer.children.push(newNode);\n        } else if (newDepth > lastDepth) {\n            if (!('children' in currContainer)) {\n                throw new Error(`Line ${i + 1}: entry of type ${currContainer.type} cannot have children.\\n${line}`);\n            }\n            if (currContainer.type === 'tag') {\n                if (atomic.includes(currContainer.tagName)) {\n                    throw new Error(`Line ${i + 1}: tag ${currContainer.tagName} cannot have children.\\n${line}`);\n                }\n                if (currContainer.hasText) {\n                    throw new Error(`Line ${i + 1}: tag ${currContainer.tagName} has a text node and cannot have children.\\n${line}`);\n                }\n            }\n            goDown(prevNode, newDepth);\n            currContainer.children.push(newNode);\n        } else {\n            currContainer.children.push(newNode);\n        }\n        prevNode = newNode;\n    }\n    return tree;\n};\n\nconst escapist = /`/g;\nconst escapeQuotes = str => str.replace(escapist, '\\\\`');\n\nconst getClassesIds = ids => {\n    const id = idsPattern.exec(ids)?.[0],\n          classes = ids.match(classesPattern);\n    let str = '';\n    if (id) {\n        str += ` id=\"${id.slice(1)}\" `;\n    }\n    if (classes?.length) {\n        str += ' class=\"';\n        for (const c of classes) {\n            str += c.slice(1) + ' ';\n        }\n        str = str.slice(0, -1) + '\" ';\n    }\n    return str.slice(0, -1);\n};\n\nlet isPrevNodeHtml;\nconst looseEnd = isHtml => {\n    let output = '';\n    if (isPrevNodeHtml && !isHtml) {\n        output = '`;';\n    } else if (!isPrevNodeHtml && isHtml) {\n        output = 'html+=`';\n    }\n    isPrevNodeHtml = isHtml;\n    return output;\n};\n\nconst walk = (node, format = false) => {\n    if (node instanceof Array) {\n        return node.map(walk).join('');\n    }\n    let out;\n    switch (node.type) {\n        case 'comment':\n            return `${looseEnd(true)}<!--${escapeQuotes(node.value)}-->`;\n        case 'code':\n            out = looseEnd(false) + node.value;\n            const b = controlOpPattern.test(node.value);\n            if (b) {\n                out += '{';\n            }\n            if (node.children?.length) {\n                out += walk(node.children);\n            }\n            if (b) {\n                out += `${looseEnd(false)}}`;\n            }\n            isPrevNodeHtml = false;\n            return out;\n        case 'text':\n            return `${looseEnd(true)}${escapeQuotes(node.value)}`;\n        case 'tag':\n            const a = node.atomic;\n            let attrsString = node.attrs? (' ' + node.attrs) : '';\n            if (node.ids) {\n                attrsString += getClassesIds(node.ids);\n            }\n            out = `${looseEnd(true)}<${node.tagName}${escapeQuotes(attrsString)}${a ? '/' : ''}>`;\n            if (node.children?.length) {\n                out += walk(node.children);\n            }\n            if (!a) {\n                out += `${looseEnd(true)}</${node.tagName}>`;\n            }\n            isPrevNodeHtml = true;\n            return out;\n    }\n};\nconst makeRenderer = code => {\n    try {\n        return new Function('state', code);\n    } catch (e) {\n        console.error(code);\n        throw new Error(`Malformed JS code: ${e.message}`);\n    }\n};\nconst compile = (tree, format = false) => {\n    let output = 'let html = \\'\\';';\n    isPrevNodeHtml = false;\n    output += walk(tree.children, format);\n    if (isPrevNodeHtml) {\n        output += '`;';\n    }\n    output += 'return html;'\n    return output;\n};\nexport default {\n    render(input, state = {}, format = false) {\n        const tree = parse(input);\n        const compiled = compile(tree, false);\n        return makeRenderer(compiled)(state);\n    },\n    renderer(input, format = false) {\n        return makeRenderer(compile(parse(input), false));\n    }\n};"],"names":["tagPattern","classesPattern","idsPattern","indentation","controlOpPattern","atomic","parse","input","lines","split","tree","type","children","depthStack","tagStack","dotTag","dotDepth","currContainer","prevNode","dotTextDepth","i","length","line","trimmed","trim","push","value","lastDepth","newDepth","str","exec","slice","newNode","trimStart","startsWith","parsed","Error","tagName","ids","attrs","text","dot","groups","hasText","Boolean","includes","indexOf","join","pop","node","depth","escapist","escapeQuotes","replace","isPrevNodeHtml","looseEnd","isHtml","output","walk","format","Array","map","out","b","test","a","attrsString","id","classes","match","c","getClassesIds","makeRenderer","code","Function","e","console","error","message","compile","render","state","compiled","renderer"],"mappings":"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"}